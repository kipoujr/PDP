<!DOCTYPE html>
<html lang="el">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
		<title>Competitive Programming - From Zero to Hero</title>

		<link rel="icon" href="../../../../favicon.ico" type="image/x-icon">
		
        <meta name="viewport" content="width=device-width, user-scalable=false;"> 
		<link href="../../../../css/style.css" rel="stylesheet">
		<link href="../../../../css/normalize.css" rel="stylesheet">
		<link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Open+Sans" />
		<script src="../../../../js/modernizr.js"></script>
		
		<!-- Latest compiled and minified CSS -->
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">

		<!-- Optional theme -->
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap-theme.min.css">

		<!-- Latest compiled and minified JavaScript -->
		<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
		
		<!-- include javascript, jQuery FIRST -->
		<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
		<script src="http://netdna.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
		<script src="http://maps.googleapis.com/maps/api/js?keypNtVooHR6ApHKSuIDxcY0Hjr&sensor=false"></script>
	

	</head>
	<body>
		<div id="wrapper">

	        <!-- Sidebar -->
	        <div id="sidebar-wrapper">
	            <ul class="sidebar-nav">
	                <li class="sidebar-brand">
	                    <a href="../../../../index.html">
	                        Competitive Programming
	                    </a>
	                </li>
	                <li>
	                    <a href="../../../../index.html">Αρχική</a>
	                </li>
	                <li>
	                    <a href="../../../../zero.html">Zero</a>
	                </li>
					<li>
	                    <a href="../../../../intermediate.html">Intermediate</a>
	                </li>
					<li>
						<a href="../../../../hero.html">Hero</a>
					</li>
	                <li>
	                    <a href="../../../../assets.html">Χρήσιμο Υλικό</a>
	                </li>	               
	            </ul>
	        </div>
	        <!-- /#sidebar-wrapper -->

	        <!-- Page Content -->
	        <div id="page-content-wrapper">
	            <div class="container">
	            	<div class="row hidden-lg hidden-md hidden-sm">
	            		<a href="#menu-toggle" class="btn btn-default" id="menu-toggle">Menu</a>
	            	</div>
		            <div id ="copy" class="row copyright">
		            		<p class="copyrightp">Copyright &copy;2018. All rights reserved. Created by <a href="http://www.codev.gr" target="_blank">CoDev</a></p>            
		            </div>

					<div class="row">
						<div class="col-md-9 col-lg-9 col-sm-9 col-xs-12">
							<h3 class="center">Θεωρία</h3>
							<p class="mypad">Έστω ότι θέλουμε να αποθηκεύσουμε σε ένα Binary Search Tree (BST) τρεις πόλεις: <em>Αθήνα, Θεσσαλονίκη, Μύκονος</em>. Όπως γνωρίζουμε, το δέντρο μας θα έμοιαζε κάπως έτσι: <img src="node_oriented.png" /></p>
							<p class="mypad">Παρατηρούμε ότι κάποιες πόλεις (Αθήνα, Μύκονος) αποθηκεύθηκαν στα φύλλα, ενώ κάποιες άλλες (Θεσσαλονίκη) σε εσωτερικούς κόμβους. Έχουμε λοιπόν ένα <strong>Node-Oriented</strong> Tree, η πληροφορία του δηλαδή αποθηκεύεται στους κόμβους. Υπάρχει όμως και μια άλλη αναπαράσταση, τα <strong>Leaf-Oriented</strong> Trees, που η πληροφορία αποθηκεύεται μόνο στα φύλλα. Και τότε τι κρατάμε στους εσωτερικούς κόμβους; Απλές πινακίδες για να μας βοηθούν στην αναζήτηση: <img src="leaf_oriented.png" /></p>
							<p class="mypad">Βλέπουμε ότι η πληροφορία (οι πραγματικές πόλεις) αποθηκεύονται στα φύλλα, ενώ στους εσωτερικούς κόμβους έχουμε απλά βοηθητική πληροφορία. Για παράδειγμα, η πρώτη πινακίδα αντί για Θεσσαλονίκη θα μπορούσε να γράφει "ΙΙΙΙΙ" καθώς κι αυτό το κείμενο θα διαχώριζε στα αριστερά Αθήνα-Θεσσαλονίκη και δεξιά τη Μύκονο.</p>
							<p class="mypad">Η βασική ιδέα των Leaf-Oriented BSTs που μας απασχολούν είναι ότι αποφεύγουμε πλήρως το ζύγισμα του δέντρου. Αντί να εισάγουμε σιγά σιγά τα δεδομένα, το δέντρο θεωρείται χτισμένο εξαρχής, μοιράζοντας βέλτιστα (στη μέση) τα στοιχεία. Απλώς άλλα τα σημειώνουμε ως ενεργά και άλλα όχι. Έτσι, ακόμα και να έχουμε 1 στοιχείο μέσα στη δομή μας, ο χρόνος θα είναι πάλι λογαριθμικός. Αυτό στη θεωρία είναι κακό, για τους διαγωνισμούς όμως είναι ταχύτατο, τόσο στη συγγραφή όσο και στην εκτέλεση.</p>
							<p class="mypad">Ας θυμηθούμε τον τρόπο αποθήκευσης που είχαμε χρησιμοποιήσει και στις Heap (δε μας ενδιαφέρει η ίδια η Heap, μόνο το πώς την αποθηκεύαμε).</p>
							<img src="heap_indexing_CLRS.png" />
							<p class="mypad">Η παρουσίαση εκτέλεσης (μαζί με κώδικα) για απάντηση σε ερωτήματα <em>ελάχιστης τιμής</em> δίνεται <a href="leaf-oriented_BSTs.pdf">εδώ</a>, και χρησιμοποίει το ίδιο ακριβώς τρικ αποθήκευσης της heap (θυμόμαστε <a href="../../../../read_pdf.html">αυτό</a>). Παρακάτω θα αναλύσουμε την πολυπλοκότητα:</p>
							<p class="mypad">Προφανώς το update κοστίζει O(logN), αφού το ύψος του δέντρου είναι logN, και σε κάθε βήμα μετά από σταθερό αριθμό από operations στρίβει στο αριστερό ή στο δεξί παιδί. Τι γίνεται με τα query όμως, που μπορεί να σπάσουν και στα 2 παιδιά;</p>
							<p class="mypad">Θα δείξουμε πρώτα ότι τα εύκολα ερωτήματα κοστίζουν O(logN). Θα λέμε εύκολο ένα ερώτημα όταν ζητάει την ελάχιστη τιμή από την αρχή ως κάποια θέση. Έτσι αν είμαστε στη ρίζα [1,Ν], εύκολα είναι τα ερωτήματα [1,2], [1,5], κλπ, ενώ δύσκολα είναι τα [2,3], [2,4] κλπ. Αντίστοιχα αν είμαστε στον κόμβο [5,8], τότε τα εύκολα ερωτήματα είναι τα [5,7], [5,8] κλπ.</p>
							<p class="mypad">Γιατί λοιπόν τα εύκολα ερωτήματα κοστίζουν O(logN); Αφού ζητάνε την αρχή, θα πάμε σίγουρα στο αριστερό παιδί. Αν δεν πάμε στο δεξί, τότε είναι προφανές ότι δεν υπάρχει πρόβλημα. Αν πάμε και στο δεξί, τότε αφού θέλουμε και την αρχή και κάτι από το δεξί, άρα θέλουμε κι όλα τα ενδιάμεσα. Άρα θέλουμε ολόκληρο το αριστερό παιδί, του οποίου την απάντηση παίρνουμε απευθείας (Ο(1)), και κατόπιν θα συνεχίσουμε μόνο στο δεξί παιδί. Άρα κάθε φορά συνεχίζουμε πρακτικά σε ένα μόνο παιδί.</p>
							<p class="mypad">Συμμετρικά, και τα ερωτήματα που τελειώνουν στο τέλος του κόμβου είναι εύκολα. Τι γίνεται με τα γενικά ερωτήματα; Προχωρούνε σε ένα παιδί, μέχρι που κάποια στιγμή θα σπάσουν σε 2. Παρατηρούμε ότι όταν σπάσουν, έχουμε δύο εύκολα ερωτήματα! Το αριστερό τελειώνει στο τέλος, και το δεξί αρχίζει στην αρχή (αλλιώς δε θα έσπαγαν!). Επομένως ο χρόνος είναι περίπου 2*O(logN) = O(logN).</p>
							<p class="mypad">Για να καταλάβουμε καλύτερα τη δομή, μπορούμε να πειραματιστούμε με <a href="https://visualgo.net/en/segmenttree">αυτή</a> την εφαρμογή. Στην ανανέωση βάζουμε L=R. Στο <a href="../Lazy_propagation/index.html">επόμενο</a> υποκεφάλαιο θα δούμε πώς να κάνουμε γενικά Range Updates με Lazy Propagation.</p>
						</div>
					</div>
					<div class="row">
						<div class="col-md-9 col-lg-10 col-sm-8 col-xs-12">
							<hr class="hr">
						</div>
					</div>

					<div class="row">
						<div class="col-md-9 col-lg-9 col-sm-9 col-xs-12">
							<h3 class="center">Σημειώσεις υλοποίησης</h3>
							<p class="mypad">Ο πίνακάς μας πρέπει να είναι μεγέθους 4*Ν. Μέχρι το 2*Ν προκύπτει επειδή πέρα από τα Ν φύλλα έχουμε και τους Ν-1 εσωτερικούς κόμβους. Η υπόλοιπη διαφορά οφείλεται στην heap αναπαράστασή μας.</p>
							<p class="mypad">Αν δείτε τις <a href="leaf-oriented_BSTs.pdf">διαφάνειες</a>, η θέση του κόμβου [6,6] στον πίνακα είναι 24, δηλαδή ήδη πάνω από το 2*Ν=20. Αν σας αρκεί, το 4*Ν είναι πάντα αρκετό. Αν όχι, προσέξτε ότι η heap αναπαράσταση ´θεωρεί´ ότι το τελευταίο επίπεδο είναι γεμάτο. Ενώ εμείς πχ δε δίνουμε σε κανένα κόμβο την τιμή 18, και θα μπορούσε να ανατεθεί στον κόμβο [6,6], η heap αναπαράσταση φαντάζεται ότι οι κόμβοι [3,3], [4,4], [5,5] έχουν από δύο παιδιά, και σε αυτά τα υποθετικά παιδιά αναθέτει τις μικρές θέσεις μνήμης.</p>
							<p class="mypad">Έτσι μπορεί να έχουμε κάποιο παιδί στο τελευταίο επίπεδο που έχει μεγάλη διεύθυνση, όπως το [6,6]. Αφού όμως τα φύλλα είναι Ν, το τελευταίο επίπεδο έχει μέγεθος το πολύ 2*Ν, κι άρα το 4*Ν  αρκεί για να δώσουμε διεύθυνση σε οποιοδήποτε κόμβο.</p>
							<p class="mypad">Επίσης άλλες υλοποιήσεις (όπως η ενδεικτική) διαλέγουν σωστά το παιδί (ή τα παιδιά) όπου πρέπει να κατέβει η αναδρομή. Άλλες πηγαίνουν και στα 2 παιδιά, κι απλώς επιστρέφουν αν το διάστημα του κόμβου είναι τελείως ξένο με το διάστημα του ερωτήματος. Διαλέξτε ό,τι σας ταιριάζει περισσότερο!</p>
						</div>
					</div>
					<div class="row">
						<div class="col-md-9 col-lg-10 col-sm-8 col-xs-12">
							<hr class="hr">
						</div>
					</div>

					<div class="row">
						<div class="col-md-9 col-lg-9 col-sm-9 col-xs-12" >
							<h3 class="center">Ασκήσεις</h3>
							<ol><li>Εφαρμογή <a href="https://www.spoj.com/problems/DCEPC206/">DCEPC206</a> - Εκφώνηση και Judge | <a href="http://piyushkumarblog.blogspot.com/2013/01/blog-post.html">Κώδικας</a> | <a href="dcepc206.zip">Offline</a></li>
								<li>(*) <a href="https://www.spoj.com/problems/GSS1/">GSS1</a> και η δυναμική εκδοχή του <a href="https://www.spoj.com/problems/GSS3/">GSS3</a> - Εκφώνηση και Judge | <a href="https://www.quora.com/What-is-the-approach-for-solving-GSS1-and-GSS3-on-SPOJ-using-segment-trees">Λύση</a> | <a href="https://github.com/vitsalis/SPOJ/blob/master/GSS3/gss3.cpp">Κώδικας</a> | <a href="gss1-3.zip">Offline</a></li>
								<li>(*) <a href="https://www.spoj.com/problems/BRCKTS/">BRCKTS</a> - Εκφώνηση και Judge | <a href="https://www.quora.com/What-is-the-algorithm-to-solve-the-BRCKTS-problem-of-SPOJ">Λύση</a> στο σχόλιο του Pardyot Shahi | <a href="https://gist.github.com/PrashantYadav/b27287c48672c4e66ce2">Κώδικας</a> | <a href="brckts.zip">Offline</a></li>
							</ol>
						</div>
					</div>

				</div>
				<!-- /#container -->
		   </div>
		   <!-- /#page-content-wrapper -->

	   </div>
	   <!-- /#wrapper -->
		   
	   <!-- Menu Toggle Script -->
	   <script>
		   
		   var justPressedMenu = 0;
		   $("#page-content-wrapper").click(function(e) {
			   if ( justPressedMenu != 1 ) {
				   $("#wrapper").removeClass("toggled");
			   } else
				   justPressedMenu = 0;
		   });
		  
		   $("#menu-toggle").click(function(e) {
			   e.preventDefault();
			   $("#wrapper").toggleClass("toggled");
			   justPressedMenu = 1;
		   });
	 
	   </script>
		<!--Copyright stick to bottom -->
	   <script>
		   var available = $(window).height();
		   var page = $("#page-content-wrapper").height();

		   if(page<available){
			   var h = available;
			   $("#copy").css("top", h-h*0.05);
		   }				
			   
		   $(".copyrightp").css("display","block");
		   
		   $(window).resize(function() {
			   available = $(window).height();
			   page = $("#page-content-wrapper").height();
			   
			   if(page<available){
				   var h = available;
				   $("#copy").css("top", h);
			   }else{
				   $("#copy").css("top", page+40);
			   }
			   $(".copyrightp").css("display","block");
			});
		   
	   </script>
	  
   </body>
</html>
