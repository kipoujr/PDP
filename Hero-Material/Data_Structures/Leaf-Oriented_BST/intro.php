<?php
	$title = "Competitive Programming - From Zero to Hero";
	include_once($_SERVER['DOCUMENT_ROOT']."/PDP/header.php");
?>
					<div class="row">
						<div class="col-md-9 col-lg-9 col-sm-9 col-xs-12">
							<h3 class="center">Θεωρία</h3>
							<p class="mypad">Ίσως η πιο σημαντική δομή δεδομένων! Πρέπει να μάθετε να την γράφετε τέλεια, γιατί θα σας λύσει τα χέρια. Καλό θα ήταν σε αυτό το κεφάλαιο να επιμείνετε πολύυυ καιρό (άνω του μήνα). </p>
							<p class="mypad">Η δομή αυτή μας επιτρέπει να τροποποιούμε τα στοιχεία μας και να απαντάμε ερωτήματα για πολλά στοιχεία (π.χ. τα μισά στοιχεία ενός πίνακα) σε O(logN) χρόνο! Για παράδειγμα μας επιτρέπει να αλλάξουμε σε 1025 την τιμή της θέσης 7, και να βρίσκουμε την ελάχιστη τιμή μεταξύ της θέσης 5 και της θέσης N-2, σε λογαριθμικό χρόνο.</p>
							<p class="mypad">Η μοναδική απαίτηση για τα ερωτήματα είναι να είναι <em>διαχωρίσιμα</em> (<a href="https://www.sciencedirect.com/science/article/pii/0020019079901170" title="DOI: 10.1016/0020-0190(79)90117-0">Decomposable</a>). Αυτό σημαίνει ότι αν μου χαρίσουν την απάντηση για το πρώτο μισό και την απάντηση για το δεύτερο μισό, μπορώ να τις συνδυάσω γρήγορα (συνήθως σε Ο(1)), και να πάρω τη συνολική απάντηση. Πολλά ερωτήματα είναι διαχωρίσιμα. Οι κλασσικότερες εφαρμογές:</p>
								<ul><li><strong>Άθροισμα</strong>: Συνολικό_Άθροισμα = Αριστερό_Άθροισμα + Δεξί_Άθροισμα</li>
									<li><strong>Ελάχιστη τιμή</strong>: Συνολικό_Ελάχιστο = min(Αριστερό_Ελάχιστο, Δεξί_Ελάχιστο)</li>
								</ul>
							<p class="mypad">Ας αναφέρουμε και ένα χαρακτηριστικό παράδειγμα μη-διαχωρίσιμου ερωτήματος, την εύρεση του πλήθους διαφορετικών αριθμών. Βλέπουμε ότι οι πίνακες <em>[3,5,25,1]</em> και <em>[3,5,23,3]</em> δίνουν ίδιες απαντήσεις αριστερά και δεξιά (όλες ίσες με 2), αλλά η συνολική απάντηση διαφέρει (4 και 3 αντιστοίχως).</p>
							<p class="mypad">Τονίζουμε ότι δε θα δούμε κάποια καινούρια δομή δεδομένων! Παρότι ψευδώς κυκλοφορεί με το όνομα <strong>Segment Tree</strong> ή και <em>Interval Tree</em> στους κύκλους των competitive programmers (και μόνο έτσι θα βρείτε πηγές), η αλήθεια είναι ότι πρόκειται απλώς για ένα δέντρο που η πληροφορία βρίσκεται στα φύλλα του. Τι εννοούμε με αυτό;</p>
							<p class="mypad">Έστω ότι θέλουμε να αποθηκεύσουμε σε ένα Binary Search Tree (BST) τρεις πόλεις: <em>Αθήνα, Θεσσαλονίκη, Μύκονος</em>. Όπως γνωρίζουμε, το δέντρο μας θα έμοιαζε κάπως έτσι: <img src="node_oriented.png" /></p>
							<p class="mypad">Παρατηρούμε ότι κάποιες πόλεις (Αθήνα, Μύκονος) αποθηκεύθηκαν στα φύλλα, ενώ κάποιες άλλες (Θεσσαλονίκη) σε εσωτερικούς κόμβους. Έχουμε λοιπόν ένα <strong>Node-Oriented</strong> Tree, η πληροφορία του δηλαδή αποθηκεύεται στους κόμβους. Υπάρχει όμως και μια άλλη αναπαράσταση, τα <strong>Leaf-Oriented</strong> Trees, που η πληροφορία αποθηκεύεται στα φύλλα. Και τότε τι κρατάμε στους εσωτερικούς κόμβους; Απλές πινακίδες για να μας βοηθούν στην αναζήτηση: <img src="leaf_oriented.png" /></p>
							<p class="mypad">Βλέπουμε ότι η πληροφορία (οι πραγματικές πόλεις) αποθηκεύονται στα φύλλα, ενώ στους εσωτερικούς κόμβους έχουμε απλά βοηθητική πληροφορία. Για παράδειγμα, η πρώτη πινακίδα αντί για Θεσσαλονίκη θα μπορούσε να γράφει "ΙΙΙΙΙ" καθώς κι αυτό το κείμενο θα διαχώριζε στα αριστερά Αθήνα-Θεσσαλονίκη και δεξιά τη Μύκονο.</p>
							<p class="mypad">Η βασική ιδέα των Leaf-Oriented BSTs που μας απασχολούν είναι ότι αποφεύγουμε πλήρως το ζύγισμα του δέντρου. Αντί να εισάγουμε σιγά σιγά τα δεδομένα, χτίζουμε όλο το δέντρο από τη στιγμή που διαβάζουμε το Ν, μοιράζοντας βέλτιστα (στη μέση) τα στοιχεία. Έτσι, ακόμα και να έχουμε 1 στοιχείο μέσα στη δομή μας, ο χρόνος θα είναι πάλι λογαριθμικός. Αυτό στη θεωρία είναι κακό, για τους διαγωνισμούς όμως είναι ταχύτατο, τόσο στη συγγραφή όσο και στην εκτέλεση.</p>
							<p class="mypad">Ας θυμηθούμε τον τρόπο αποθήκευσης που είχαμε χρησιμοποιήσει και στις Heap (δε μας ενδιαφέρει η ίδια η Heap, μόνο το πώς την αποθηκεύαμε).</p>
							<img src="heap_indexing_CLRS.png" />
							<p class="mypad">Ένα παράδειγμα εκτέλεσης (μαζί με κώδικα) για απάντηση σε ερωτήματα <em>ελάχιστης τιμής</em> δίνεται <a href="leaf-oriented_BSTs.pdf">εδώ</a>, και χρησιμοποίει το ίδιο ακριβώς τρικ αποθήκευσης της heap. Παρακάτω θα αναλύσουμε την πολυπλοκότητα:</p>
							<p class="mypad">Προφανώς το update κοστίζει O(logN), αφού το ύψος του δέντρου είναι logN, και σε κάθε βήμα μετά από σταθερό αριθμό από operations στρίβει στο αριστερό ή στο δεξί παιδί. Τι γίνεται με τα query όμως, που μπορεί να σπάσουν και στα 2 παιδιά;</p>
							<p class="mypad">Θα δείξουμε πρώτα ότι τα εύκολα ερωτήματα κοστίζουν O(logN). Θα λέμε εύκολο ένα ερώτημα όταν ζητάει την ελάχιστη τιμή από την αρχή ως κάποια θέση. Έτσι αν είμαστε στη ρίζα [1,Ν], εύκολα είναι τα ερωτήματα [1,2], [1,5], κλπ, ενώ δύσκολα είναι τα [2,3], [2,4] κλπ. Αντίστοιχα αν είμαστε στον κόμβο [5,8], τότε τα εύκολα ερωτήματα είναι τα [5,7], [5,8] κλπ.</p>
							<p class="mypad">Γιατί λοιπόν τα εύκολα ερωτήματα κοστίζουν O(logN); Αφού ζητάνε την αρχή, θα πάμε σίγουρα στο αριστερό παιδί. Αν δεν πάμε στο δεξί, τότε είναι προφανές ότι δεν υπάρχει πρόβλημα. Αν πάμε και στο δεξί, τότε αφού θέλουμε και την αρχή και κάτι από το δεξί, άρα θέλουμε κι όλα τα ενδιάμεσα. Άρα θέλουμε ολόκληρο το αριστερό παιδί, του οποίου την απάντηση παίρνουμε απευθείας (Ο(1)), και κατόπιν θα συνεχίσουμε στο δεξί παιδί. Άρα κάθε φορά συνεχίζουμε πρακτικά σε ένα μόνο παιδί.</p>
							<p class="mypad">Συμμετρικά, και τα ερωτήματα που τελειώνουν στο τέλος του κόμβου είναι εύκολα. Τι γίνεται με τα γενικά ερωτήματα; Προχωρούνε σε ένα παιδί, μέχρι που κάποια στιγμή θα σπάσουν σε 2. Παρατηρούμε ότι όταν σπάσουν, έχουμε δύο εύκολα ερωτήματα! Το αριστερό τελειώνει στο τέλος, και το δεξί αρχίζει στην αρχή (αλλιώς δε θα έσπαγαν!). Επομένως ο χρόνος είναι περίπου 2logN = O(logN).
							<p class="mypad">Για να καταλάβουμε καλύτερα τη δομή, μπορούμε να πειραματιστούμε με <a href="https://visualgo.net/en/segmenttree">αυτή</a> την εφαρμογή.
							<p class="mypad">Υποσημείωση (πλήρως άχρηστη για διαγωνισμούς): Οι ονομασίες Segment Tree και Interval Tree δεν είναι απλώς περιττές, αλλά λανθασμένες, καθώς υπάρχουν ήδη 2 δομές δεδομένων με αυτά τα ονόματα (βλέπε <a href="https://www.springer.com/gp/book/9783662034279" title="DOI: 10.1007/978-3-662-03427-9">εδώ</a>) που απαντούν ερωτήματα σχετικά με ευθύγραμμα τμήματα (τα Segment Trees ερωτήματα δύο διαστάσεων, τα Interval Trees μίας διάστασης). Παρόλα αυτά κρατάμε στο νου μας την ονομασία Segment Tree για να μπορούμε να συνεννοηθούμε με όσους το ξέρουν έτσι.</p>
						</div>
					</div>
					<div class="row">
						<div class="col-md-9 col-lg-10 col-sm-8 col-xs-12">
							<hr class="hr">
						</div>
					</div>					

					<div class="row">
						<div class="col-md-9 col-lg-9 col-sm-9 col-xs-12" >
							<h3 class="center">Ασκήσεις</h3>
							<ol><li>(*) <a href="">Sound</a> | <a href="https://dmoj.ca/problem/boi2007p3">Judge</a> | <a href="http://www.boi2007.de/tasks/book.pdf">Λύση<a/> | <a href="http://www.boi2007.de/tasks/testdata-sound.tar.gz">Testcases</a> | <a href="http://www.boi2007.de/tasks/solution-sound.tar.gz">Κώδικας</a> | <a href="sound.zip">Offline</a></li>
							</ol>
						</div>
					</div>

<?php
	include 'footer.html';
?>
